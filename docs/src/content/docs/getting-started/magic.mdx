---
title: Welcome to Spawn
description: The Database Build System for PostgreSQL and beyond.
---

Spawn is a Database Build System. It currently supports PostgreSQL via psql, but with plans to support many other databases in the future. It includes core features such as:

- Create and apply migrations
- Testing system
- Reusable components
- Easy updating of database functions and views while maintaining history

## Getting started

First, initialize a new Spawn project with Docker support:

```bash
spawn init --docker
```

This creates a `spawn.toml` configuration file, a `docker-compose.yaml` for local PostgreSQL development, and the necessary project structure. Start your database:

```bash
docker compose up -d
```

You're now ready to create migrations!

## The magic

Spawn solves a few pain points for database development, including:

- How do I update a database function, keeping the change history visible via git in an easy to review way, all while ensuring old migrations work?
- How do I run complex tests against my database?
- How can I use external data in my migrations?
- How do I create per-migration (not yet available) as well as regression tests?
- How can I apply some changes to local but not prod?

Spawn solves these pain points through four mechanisms:

1. Separate the components (views, functions, triggers, reusable snippets) from the migrations.
2. Content Addressable Storage (CAS), much like git, for components. Pin migrations to specific versions of components.
3. Dynamic SQL generation via templating.
4. Comprehensive testing framework.

### Components

Instead of storing your functions inside the migration script, store them in your `spawn/components` folder. For example, you may create a component with the following contents, stored in `spawn/components/functions/add_fee.sql`:

```sql
CREATE OR REPLACE FUNCTION add_fee(a NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a * 1.1;
END;
$$ LANGUAGE plpgsql;
```

Then you create your new migration:

```bash
spawn migration new add_fee
# creating migration with name 20260131075608-add_fee
# creating migration at spawn/migrations/20260131075608-add_fee/up.sql
# New migration created: 20260131075608-add_fee
```

Now, open up that migration script and reference your migration:

```sql
BEGIN;

{% include 'functions/add_fee.sql' %}

COMMIT;
```

Finally, use `build` to see how the final SQL looks:

```bash
spawn migration build 20260131075608-add_fee
```

```sql
-- Output:
BEGIN;

CREATE OR REPLACE FUNCTION add_fee(a NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a * 1.1;
END;
$$ LANGUAGE plpgsql;

COMMIT;
```

Easy!

### Pinning via CAS

You've realised now that you'd rather your add_fee function pull the fee from a table, so that updating the fee is as easy as updating an entry in that table.

However, if you update the component directly, we hit two problems:

1. Any old migration tests (not yet implemented) that depend on that functionality will break.
2. If we try running old migrations against a new database, `20260131075608-add_fee` will now pick up the new version of the component instead of the old.

We can solve both of these problems via pinning. Pinning pins the migration to a specific version of the components folder.

If you try and apply your migration now, you'll hit an error:

```bash
spawn migration apply 20260131075608-add_fee
Error: Failed to generate migration '20260131075608-add_fee'. Is it pinned? Run `spawn migration pin 20260131075608-add_fee` or use `--no-pin` to apply without pinning.

Caused by:
    0: could not load pinned files lock file
    1: NotFound (permanent) at read, context: { service: fs, path: spawn/migrations/20260131075608-add_fee/lock.toml, range: 0- } => entity not found, source: No such file or dir
ectory (os error 2)
    2: No such file or directory (os error 2)
```

The error tells us that we need to either pin the pingration, or use `--no-pin`. Run like so:

```bash
spawn migration pin 20260131075608-add_fee
# Migration pinned: 257372323412c39db23080ade53cb9da
```

This creates a `lock.toml` file in the migration folder:

```bash
ls spawn/migrations/20260131075608-add_fee
lock.toml       up.sql

cat spawn/migrations/20260131075608-add_fee/lock.toml
```

```toml
pin = "257372323412c39db23080ade53cb9da"
```

This stores a snapshot of the components inside `spawn/pinned` in a manner very similar to how git works. The files produced by pin are stored in `/pinned`.

Let's apply this to our locally running database:

```bash
% spawn migration apply

TARGET: postgres_psql
ENVIRONMENT: dev

The following 1 migration will be applied:
  1. 20260131075608-add_fee

Do you want to apply these migrations? [y/N]

Migration '20260131075608-add_fee' applied successfully
All migrations applied successfully.
```

Or alternatively, you can target this specific migration to apply:

```bash
spawn migration apply 20260131075608-add_fee
```

You can see that it has been applied:

```bash
% spawn migration status

┌────────────────────────┬────────────┬────────┬──────────┬───────────┐
│ Migration              │ Filesystem │ Pinned │ Database │ Status    │
├────────────────────────┼────────────┼────────┼──────────┼───────────┤
│ 20260131075608-add_fee │ ✓          │ ✓      │ ✓        │ ✓ Applied │
└────────────────────────┴────────────┴────────┴──────────┴───────────┘

Success.
```

And can verify by calling it via docker using psql

```bash
% docker exec -it postgres-db psql -U postgres -d postgres -c "select add_fee(12.2)"

 add_fee
---------
   13.42
(1 row)
```

Now let's make a new migration that updates the component:

```bash
% spawn migration new update-add-func

creating migration with name 20260131080417-update-add-func
creating migration at spawn/migrations/20260131080417-update-add-func/up.sql
New migration created: 20260131080417-update-add-func
```

We can edit the component in place, so that we have a useful git record of changes made over time, and so that PRs are easier to review. We update the migration in place. In this example, we are going to update the function to obtain the base fee multiplier from a table rather than hard coded into the function. Create the migration first, replacing the contents of your new `<timestamp>-update-add-func` migration:

```sql
BEGIN;

CREATE TABLE fee (
    name TEXT PRIMARY KEY,
    amount NUMERIC(3, 2)
);

INSERT INTO fee (name, amount) VALUES ('base', 0.12);

{% include 'functions/add_fee.sql' %}

COMMIT;
```

And now update the component in place at `functions/add_fee.sql`, so it uses this new table:

```sql
CREATE OR REPLACE FUNCTION add_fee(a NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a * (SELECT amount FROM fee WHERE name = 'base');
END;
$$ LANGUAGE plpgsql;
```

Now if we were to build the old migration, we see the new version, but if we use `--pinned` then it builds with the component as it was originally at the time:

```bash
spawn migration pin 20260124073534-update-add-func
# Migration pinned: f12696fd7a68e4102f8c03dd23a774bf
```

The pinned version of the old migration uses the old version of the function:

```bash
spawn migration build 20260131075608-add_fee --pinned
```

:::tip[Pinning with `build` and `apply`]
`migration build` will always use the current version of components, rather than the pinned version, even if a lock file is present. Therefore, you must use --pinned to see how it will render the component when it applies.

`migration apply` will always use the pinned version by default.
:::

```sql
-- Output:
BEGIN;

CREATE OR REPLACE FUNCTION add_fee(a NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a * 1.1;
END;
$$ LANGUAGE plpgsql;

COMMIT;
```

The new migration uses the new version of the function:

```bash
spawn migration build 20260124073534-update-add-func --pinned
```

```sql
-- Output:
BEGIN;

CREATE TABLE fee (
    name TEXT PRIMARY KEY,
    amount NUMERIC(3, 2)
);

INSERT INTO fee (name, amount) VALUES ('base', 0.12);

CREATE OR REPLACE FUNCTION add_fee(a NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a * (SELECT amount FROM fee WHERE name = 'base');
END;
$$ LANGUAGE plpgsql;

COMMIT;
```

### Dynamic templating

The power of Spawn templating comes not just from being able to organise SQL into components, but also to make use of dynamic data at generation time. This is what makes Spawn a Database Build System.

Spawn includes by default some useful variables. For example, we may have some data we only want to show in dev builds:

```sql
{%- if env == "dev" %}
INSERT INTO fee (name, amount) VALUES ('high-test', 0.98);
{% endif %}
```

Now if we run it, we see that it doesn't show this insert:

```bash
spawn migration build 20260124073534-update-add-func --pinned
```

```sql
-- Output:
BEGIN;

CREATE TABLE fee (
    name TEXT PRIMARY KEY,
    amount NUMERIC(3, 2)
);

INSERT INTO fee (name, amount) VALUES ('base', 0.12);

CREATE OR REPLACE FUNCTION add_fee(a NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a * (SELECT amount FROM fee WHERE name = 'base');
END;
$$ LANGUAGE plpgsql;

COMMIT;
```

But if we edit the database in `spawn.toml` to specify that it is a dev environment, like so:

```toml {6}
...
database = "postgres_psql"

[databases.postgres_psql]
...
environment = "dev"
command = ["docker", "exec", "-i", "postgres-db", "psql", "-U", "postgres", "postgres"]
```

Then it includes the extra insert!

```bash
spawn migration build 20260124073534-update-add-func --pinned
```

```sql {9}
BEGIN;

CREATE TABLE fee (
    name TEXT PRIMARY KEY,
    amount NUMERIC(3, 2)
);

INSERT INTO fee (name, amount) VALUES ('base', 0.12);
INSERT INTO fee (name, amount) VALUES ('high-test', 0.98);

CREATE OR REPLACE FUNCTION add_fee(a NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a * (SELECT amount FROM fee WHERE name = 'base');
END;
$$ LANGUAGE plpgsql;

COMMIT;
```
